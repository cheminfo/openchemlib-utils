{"version":3,"file":"openchemlib-utils.min.js","sources":["../src/OCL.js","../src/util/tagAtom.js","../src/diastereotopic/addDiastereotopicMissingChirality.js","../src/util/makeRacemic.js","../src/diastereotopic/getDiastereotopicAtomIDs.js","../src/diastereotopic/getDiastereotopicAtomIDsAndH.js","../src/util/isCsp3.js","../src/hose/getHoseCodesForAtom.js","../src/hose/getHoseCodesFromDiastereotopicID.js","../src/util/getAtomsInfo.js","../node_modules/is-any-array/src/index.js","../node_modules/ml-array-max/lib-es6/index.js","../node_modules/ml-array-min/lib-es6/index.js","../node_modules/ml-array-rescale/lib-es6/index.js","../node_modules/ml-matrix/src/util.js","../node_modules/ml-matrix/src/inspect.js","../node_modules/ml-matrix/src/matrix.js","../node_modules/ml-matrix/src/stat.js","../src/util/getConnectivityMatrix.js","../node_modules/ml-floyd-warshall/src/index.js","../src/hose/getHoseCodesForPath.js","../src/path/getPathsInfo.js","../node_modules/ml-matrix/src/mathOperations.js","../src/hose/getHoseCodesAndDiastereotopicIDs.js","../src/path/getShortestPaths.js","../src/diastereotopic/toDiastereotopicSVG.js"],"sourcesContent":["let OCL;\n\nexport function getOCL() {\n  if (!OCL) {\n    throw new Error('OCL has to be initialized using initOCL(OCL)');\n  }\n  return OCL;\n}\n\nexport function initOCL(newOCL) {\n  if (OCL) {\n    throw new Error('OCL-utils was already initialized with OCL');\n  }\n  OCL = newOCL;\n}\n","import { getOCL } from '../OCL';\n\nlet xAtomicNumber = 0;\n\n/**\n * Tag an atom to be able to visualize it\n * @param {OCL.Molecule} molecule\n * @param {number} iAtom\n */\nexport function tagAtom(molecule, iAtom) {\n  let customLabel = `${molecule.getAtomLabel(iAtom)}*`;\n  molecule.setAtomCustomLabel(iAtom, customLabel);\n  if (molecule.getAtomicNo(iAtom) === 1) {\n    molecule.setAtomicNo(iAtom, getXAtomicNumber());\n  } else {\n    // we can not use X because we would have problems with valencies if it is\n    // expanded hydrogens or not\n    // we can not only use a custom label because it does not count for the canonisation\n    molecule.setAtomMass(iAtom, molecule.getAtomMass(iAtom) + 5);\n  }\n  return customLabel;\n}\n\nfunction getXAtomicNumber() {\n  if (!xAtomicNumber) {\n    const OCL = getOCL();\n    xAtomicNumber = OCL.Molecule.getAtomicNoFromLabel('X');\n  }\n  return xAtomicNumber;\n}\n","import { tagAtom } from '../util/tagAtom';\nimport { getOCL } from '../OCL';\n\n/**\n * Add either missing chirality of diastereotopic missing chirality\n * The problem is that sometimes we need to add chiral bond that was not planned because it is the same group\n * This is the case for example for the valine where the 2 C of the methyl groups are diastereotopic\n * @param {OCL.Molecule} molecule\n * @param {object} [options={}]\n * @param {number} [options.esrType=cESRTypeAnd]\n */\nexport function addDiastereotopicMissingChirality(molecule, options = {}) {\n  const { Molecule } = getOCL();\n  const { esrType = Molecule.cESRTypeAnd } = options;\n\n  for (let iAtom = 0; iAtom < molecule.getAllAtoms(); iAtom++) {\n    let tempMolecule = molecule.getCompactCopy();\n    tagAtom(tempMolecule, iAtom);\n    // After copy, helpers must be recalculated\n    tempMolecule.ensureHelperArrays(Molecule.cHelperBitsStereo);\n    // We need to have >0 and not >1 because there could be unspecified chirality in racemate\n\n    for (let i = 0; i < tempMolecule.getAtoms(); i++) {\n      // changed from from handling below; TLS 9.Nov.2015\n      if (\n        tempMolecule.isAtomStereoCenter(i) &&\n        tempMolecule.getStereoBond(i) === -1\n      ) {\n        let stereoBond = tempMolecule.getAtomPreferredStereoBond(i);\n        if (stereoBond !== -1) {\n          molecule.setBondType(stereoBond, Molecule.cBondTypeUp);\n          if (molecule.getBondAtom(1, stereoBond) === i) {\n            let connAtom = molecule.getBondAtom(0, stereoBond);\n            molecule.setBondAtom(0, stereoBond, i);\n            molecule.setBondAtom(1, stereoBond, connAtom);\n          }\n          // To me it seems that we have to add all stereo centers into AND group 0. TLS 9.Nov.2015\n          molecule.setAtomESR(i, esrType, 0);\n        }\n      }\n    }\n  }\n}\n","import { getOCL } from '../OCL';\n\n/**\n *\n * @param {OCL.Molecule} [molecule] An instance of a molecule\n * @param {object} [options={}]\n * @param {object} [options.OCL] openchemlib library\n */\nexport function makeRacemic(molecule) {\n  const { Molecule } = getOCL();\n\n  // if we don't calculate this we have 2 epimers\n  molecule.ensureHelperArrays(Molecule.cHelperCIP);\n\n  // we need to make one group \"AND\" for chiral (to force to racemic, this means diastereotopic and not enantiotopic)\n  for (let i = 0; i < molecule.getAllAtoms(); i++) {\n    if (molecule.getAtomParity(i) !== Molecule.cAtomParityNone) {\n      molecule.setAtomESR(i, Molecule.cESRTypeAnd, 0); // changed to group 0; TLS 9.Nov.2015\n    }\n  }\n}\n","import { tagAtom } from '../util/tagAtom';\nimport { makeRacemic } from '../util/makeRacemic';\nimport { getOCL } from '../OCL';\n\nimport { addDiastereotopicMissingChirality } from './addDiastereotopicMissingChirality';\n\n/**\n * Returns an array of diastereotopic ID (as oclCode)\n * @param {OCL.Molecule} molecule\n */\nexport function getDiastereotopicAtomIDs(molecule) {\n  const OCL = getOCL();\n  addDiastereotopicMissingChirality(molecule);\n\n  let numberAtoms = molecule.getAllAtoms();\n  let ids = [];\n  for (let iAtom = 0; iAtom < numberAtoms; iAtom++) {\n    let tempMolecule = molecule.getCompactCopy();\n    tagAtom(tempMolecule, iAtom);\n    makeRacemic(tempMolecule);\n    // We need to ensure the helper array in order to get correctly the result of racemisation\n    ids[iAtom] = tempMolecule.getCanonizedIDCode(\n      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,\n    );\n  }\n  return ids;\n}\n","import { getOCL } from '../OCL';\n\nimport { getDiastereotopicAtomIDs } from './getDiastereotopicAtomIDs';\n// Previously getExtendedDiastereotopicAtomIDs\n\n/**\n *\n * @param {OCL.Molecule} molecule\n */\nexport function getDiastereotopicAtomIDsAndH(originalMolecule) {\n  const OCL = getOCL();\n  const molecule = originalMolecule.getCompactCopy();\n  molecule.addImplicitHydrogens();\n  // TODO Temporary code ???\n  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);\n\n  const diaIDs = getDiastereotopicAtomIDs(molecule);\n  const newDiaIDs = [];\n\n  for (let i = 0; i < diaIDs.length; i++) {\n    const diaID = diaIDs[i];\n    const newDiaID = {\n      oclID: diaID,\n      hydrogenOCLIDs: [],\n      nbHydrogens: 0,\n    };\n    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {\n      const atom = molecule.getConnAtom(i, j);\n      if (molecule.getAtomicNo(atom) === 1) {\n        newDiaID.nbHydrogens++;\n        if (newDiaID.hydrogenOCLIDs.indexOf(diaIDs[atom]) === -1) {\n          newDiaID.hydrogenOCLIDs.push(diaIDs[atom]);\n        }\n      }\n    }\n\n    newDiaIDs.push(newDiaID);\n  }\n\n  return newDiaIDs;\n}\n","/**\n * Check if a specific atom is a sp3 carbon\n * @param {OCL.Molecule} molecule\n * @param {number} atomID\n */\n\nexport function isCsp3(molecule, atomID) {\n  if (molecule.getAtomicNo(atomID) !== 6) return false;\n  if (molecule.getAtomCharge(atomID) !== 0) return false;\n  if (\n    molecule.getImplicitHydrogens(atomID) + molecule.getConnAtoms(atomID) !==\n    4\n  ) {\n    return false;\n  }\n  return true;\n}\n","import { getOCL } from '../OCL';\nimport { tagAtom } from '../util/tagAtom';\nimport { isCsp3 } from '../util/isCsp3';\nimport { makeRacemic } from '../util/makeRacemic';\n\nexport const FULL_HOSE_CODE = 1;\nexport const HOSE_CODE_CUT_C_SP3_SP3 = 2;\n\n/**\n * Returns the hose code for a specific atom number\n * @param {OCL.Molecule} originalMolecule\n * @param {number} rootAtom\n * @param {object} [options={}]\n * @param {boolean} [options.isTagged] Specify is the atom is already tagged\n */\nexport function getHoseCodesForAtom(originalMolecule, rootAtom, options = {}) {\n  const OCL = getOCL();\n  const {\n    minSphereSize = 0,\n    maxSphereSize = 4,\n    kind = FULL_HOSE_CODE,\n    isTagged = false,\n  } = options;\n\n  const molecule = originalMolecule.getCompactCopy();\n\n  if (!isTagged) {\n    let tag = tagAtom(molecule, rootAtom);\n    molecule.addImplicitHydrogens();\n    molecule.addMissingChirality();\n    molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);\n    // because ensuring helper reorder atoms we need to look again for it\n    for (let i = 0; i < molecule.getAllAtoms(); i++) {\n      if (tag === molecule.getAtomCustomLabel(i)) {\n        rootAtom = i;\n        break;\n      }\n    }\n  }\n\n  let fragment = new OCL.Molecule(0, 0);\n  let results = [];\n  let min = 0;\n  let max = 0;\n  let atomMask = new Array(molecule.getAllAtoms());\n  let atomList = new Array(molecule.getAllAtoms());\n\n  for (let sphere = 0; sphere <= maxSphereSize; sphere++) {\n    if (max === 0) {\n      atomList[0] = rootAtom;\n      atomMask[rootAtom] = true;\n      max = 1;\n    } else {\n      let newMax = max;\n      for (let i = min; i < max; i++) {\n        let atom = atomList[i];\n        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {\n          let connAtom = molecule.getConnAtom(atom, j);\n          if (!atomMask[connAtom]) {\n            switch (kind) {\n              case FULL_HOSE_CODE:\n                atomMask[connAtom] = true;\n                atomList[newMax++] = connAtom;\n                break;\n              case HOSE_CODE_CUT_C_SP3_SP3:\n                if (!(isCsp3(molecule, atom) && isCsp3(molecule, connAtom))) {\n                  atomMask[connAtom] = true;\n                  atomList[newMax++] = connAtom;\n                }\n                break;\n              default:\n                throw new Error('getHoseCoesForAtom unknown kind');\n            }\n          }\n        }\n      }\n      min = max;\n      max = newMax;\n    }\n    molecule.copyMoleculeByAtoms(fragment, atomMask, true, null);\n    if (sphere >= minSphereSize) {\n      makeRacemic(fragment);\n      results.push(\n        fragment.getCanonizedIDCode(\n          OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,\n        ),\n      );\n    }\n  }\n  return results;\n}\n","import { getOCL } from '../OCL';\n\nimport { getHoseCodesForAtom } from './getHoseCodesForAtom';\n/**\n * Returns the hose code for a specific marked atom\n * @param {string} diastereotopicID\n * @param {object} options\n */\n\nexport function getHoseCodesFromDiastereotopicID(\n  diastereotopicID,\n  options = {},\n) {\n  const OCL = getOCL();\n  const molecule = OCL.Molecule.fromIDCode(diastereotopicID);\n  molecule.addImplicitHydrogens();\n  molecule.addMissingChirality();\n\n  // One of the atom has to be marked !\n  let atomID = -1;\n  for (let i = 0; i < molecule.getAllAtoms(); i++) {\n    // we need to find the marked atom\n    const atomCustomLabel = molecule.getAtomCustomLabel(i);\n    if (atomCustomLabel != null && atomCustomLabel.endsWith('*')) {\n      atomID = i;\n      break;\n    }\n  }\n  if (atomID >= 0) {\n    options.isTagged = true;\n    return getHoseCodesForAtom(molecule, atomID, options);\n  }\n  return undefined;\n}\n","import { getOCL } from '../OCL';\nimport { getDiastereotopicAtomIDs } from '../diastereotopic/getDiastereotopicAtomIDs';\n\n/**\n * Returns various information about atoms in the molecule\n * @param {OCL.Molecule} [molecule]\n */\nexport function getAtomsInfo(molecule) {\n  const OCL = getOCL();\n  molecule.ensureHelperArrays(OCL.Molecule.cHelperRings);\n\n  let diaIDs = getDiastereotopicAtomIDs(molecule);\n\n  let results = [];\n  for (let i = 0; i < diaIDs.length; i++) {\n    let result = {\n      oclID: diaIDs[i],\n      extra: {\n        singleBonds: 0,\n        doubleBonds: 0,\n        tripleBonds: 0,\n        aromaticBonds: 0,\n        cnoHybridation: 0, // should be 1 (sp), 2 (sp2) or 3 (sp3)\n      },\n    };\n    let extra = result.extra;\n    results.push(result);\n    result.abnormalValence = molecule.getAtomAbnormalValence(i); // -1 is normal otherwise specified\n    result.charge = molecule.getAtomCharge(i);\n    result.cipParity = molecule.getAtomCIPParity(i);\n    result.color = molecule.getAtomColor(i);\n    result.customLabel = molecule.getAtomCustomLabel(i);\n    //        result.esrGroup=molecule.getAtomESRGroup(i);\n    //        result.esrType=molecule.getAtomESRType(i);\n    result.atomicNo = molecule.getAtomicNo(i);\n    result.label = molecule.getAtomLabel(i);\n    //        result.list=molecule.getAtomList(i);\n    //        result.listString=molecule.getAtomListString(i);\n    //        result.mapNo=molecule.getAtomMapNo(i);\n    result.mass = molecule.getAtomMass(i);\n    //        result.parity=molecule.getAtomParity(i);\n    //        result.pi=molecule.getAtomPi(i);\n    //        result.preferredStereoBond=molecule.getAtomPreferredStereoBond(i);\n    //        result.queryFeatures=molecule.getAtomQueryFeatures(i);\n    result.radical = molecule.getAtomRadical(i);\n    result.ringBondCount = molecule.getAtomRingBondCount(i);\n    //        result.ringCount=molecule.getAtomRingCount(i);\n    result.ringSize = molecule.getAtomRingSize(i);\n    result.x = molecule.getAtomX(i);\n    result.y = molecule.getAtomY(i);\n    result.z = molecule.getAtomZ(i);\n    result.allHydrogens = molecule.getAllHydrogens(i);\n    result.connAtoms = molecule.getConnAtoms(i);\n    result.allConnAtoms = molecule.getAllConnAtoms(i);\n\n    result.implicitHydrogens =\n      result.allHydrogens + result.connAtoms - result.allConnAtoms;\n\n    result.isAromatic = molecule.isAromaticAtom(i);\n    result.isAllylic = molecule.isAllylicAtom(i);\n    result.isStereoCenter = molecule.isAtomStereoCenter(i);\n    result.isRing = molecule.isRingAtom(i);\n    result.isSmallRing = molecule.isSmallRingAtom(i);\n    result.isStabilized = molecule.isStabilizedAtom(i);\n\n    // todo HACK to circumvent bug in OCL that consider than an hydrogen is connected to itself\n    result.extra.singleBonds =\n      result.atomicNo === 1 ? 0 : result.implicitHydrogens;\n    for (let j = 0; j < molecule.getAllConnAtoms(i); j++) {\n      let bond = molecule.getConnBond(i, j);\n      let bondOrder = molecule.getBondOrder(bond);\n      if (molecule.isAromaticBond(bond)) {\n        extra.aromaticBonds++;\n      } else if (bondOrder === 1) {\n        // not an hydrogen\n        extra.singleBonds++;\n      } else if (bondOrder === 2) {\n        extra.doubleBonds++;\n      } else if (bondOrder === 3) {\n        extra.tripleBonds++;\n      }\n    }\n    result.extra.totalBonds =\n      result.extra.singleBonds +\n      result.extra.doubleBonds +\n      result.extra.tripleBonds +\n      result.extra.aromaticBonds;\n\n    if (result.atomicNo === 6) {\n      result.extra.cnoHybridation = result.extra.totalBonds - 1;\n    } else if (result.atomicNo === 7) {\n      result.extra.cnoHybridation = result.extra.totalBonds;\n    } else if (result.atomicNo === 8) {\n      result.extra.cnoHybridation = result.extra.totalBonds + 1;\n    } else if (result.atomicNo === 1) {\n      let connectedAtom =\n        molecule.getAllConnAtoms(i) === 0\n          ? 0\n          : molecule.getAtomicNo(molecule.getConnAtom(i, 0));\n      result.extra.hydrogenOnAtomicNo = connectedAtom;\n      if (connectedAtom === 7 || connectedAtom === 8) {\n        result.extra.labileHydrogen = true;\n      }\n    }\n  }\n  return results;\n}\n","'use strict';\n\nconst toString = Object.prototype.toString;\n\nfunction isAnyArray(object) {\n  return toString.call(object).endsWith('Array]');\n}\n\nmodule.exports = isAnyArray;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the maximum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction max(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var maxValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] > maxValue) maxValue = input[i];\n  }\n\n  return maxValue;\n}\n\nexport default max;\n","import isArray from 'is-any-array';\n\n/**\n * Computes the minimum of the given values\n * @param {Array<number>} input\n * @return {number}\n */\n\nfunction min(input) {\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  }\n\n  if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var minValue = input[0];\n\n  for (var i = 1; i < input.length; i++) {\n    if (input[i] < minValue) minValue = input[i];\n  }\n\n  return minValue;\n}\n\nexport default min;\n","import max from 'ml-array-max';\nimport min from 'ml-array-min';\nimport isArray from 'is-any-array';\n\nfunction rescale(input) {\n  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  if (!isArray(input)) {\n    throw new TypeError('input must be an array');\n  } else if (input.length === 0) {\n    throw new TypeError('input must not be empty');\n  }\n\n  var output;\n\n  if (options.output !== undefined) {\n    if (!isArray(options.output)) {\n      throw new TypeError('output option must be an array if specified');\n    }\n\n    output = options.output;\n  } else {\n    output = new Array(input.length);\n  }\n\n  var currentMin = min(input);\n  var currentMax = max(input);\n\n  if (currentMin === currentMax) {\n    throw new RangeError('minimum and maximum input values are equal. Cannot rescale a constant array');\n  }\n\n  var _options$min = options.min,\n      minValue = _options$min === void 0 ? options.autoMinMax ? currentMin : 0 : _options$min,\n      _options$max = options.max,\n      maxValue = _options$max === void 0 ? options.autoMinMax ? currentMax : 1 : _options$max;\n\n  if (minValue >= maxValue) {\n    throw new RangeError('min option must be smaller than max option');\n  }\n\n  var factor = (maxValue - minValue) / (currentMax - currentMin);\n\n  for (var i = 0; i < input.length; i++) {\n    output[i] = (input[i] - currentMin) * factor + minValue;\n  }\n\n  return output;\n}\n\nexport default rescale;\n","/**\n * @private\n * Check that a row index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkRowIndex(matrix, index, outer) {\n  let max = outer ? matrix.rows : matrix.rows - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Row index out of range');\n  }\n}\n\n/**\n * @private\n * Check that a column index is not out of bounds\n * @param {Matrix} matrix\n * @param {number} index\n * @param {boolean} [outer]\n */\nexport function checkColumnIndex(matrix, index, outer) {\n  let max = outer ? matrix.columns : matrix.columns - 1;\n  if (index < 0 || index > max) {\n    throw new RangeError('Column index out of range');\n  }\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkRowVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.columns) {\n    throw new RangeError(\n      'vector size must be the same as the number of columns',\n    );\n  }\n  return vector;\n}\n\n/**\n * @private\n * Check that the provided vector is an array with the right length\n * @param {Matrix} matrix\n * @param {Array|Matrix} vector\n * @return {Array}\n * @throws {RangeError}\n */\nexport function checkColumnVector(matrix, vector) {\n  if (vector.to1DArray) {\n    vector = vector.to1DArray();\n  }\n  if (vector.length !== matrix.rows) {\n    throw new RangeError('vector size must be the same as the number of rows');\n  }\n  return vector;\n}\n\nexport function checkIndices(matrix, rowIndices, columnIndices) {\n  return {\n    row: checkRowIndices(matrix, rowIndices),\n    column: checkColumnIndices(matrix, columnIndices),\n  };\n}\n\nexport function checkRowIndices(matrix, rowIndices) {\n  if (typeof rowIndices !== 'object') {\n    throw new TypeError('unexpected type for row indices');\n  }\n\n  let rowOut = rowIndices.some((r) => {\n    return r < 0 || r >= matrix.rows;\n  });\n\n  if (rowOut) {\n    throw new RangeError('row indices are out of range');\n  }\n\n  if (!Array.isArray(rowIndices)) rowIndices = Array.from(rowIndices);\n\n  return rowIndices;\n}\n\nexport function checkColumnIndices(matrix, columnIndices) {\n  if (typeof columnIndices !== 'object') {\n    throw new TypeError('unexpected type for column indices');\n  }\n\n  let columnOut = columnIndices.some((c) => {\n    return c < 0 || c >= matrix.columns;\n  });\n\n  if (columnOut) {\n    throw new RangeError('column indices are out of range');\n  }\n  if (!Array.isArray(columnIndices)) columnIndices = Array.from(columnIndices);\n\n  return columnIndices;\n}\n\nexport function checkRange(matrix, startRow, endRow, startColumn, endColumn) {\n  if (arguments.length !== 5) {\n    throw new RangeError('expected 4 arguments');\n  }\n  checkNumber('startRow', startRow);\n  checkNumber('endRow', endRow);\n  checkNumber('startColumn', startColumn);\n  checkNumber('endColumn', endColumn);\n  if (\n    startRow > endRow ||\n    startColumn > endColumn ||\n    startRow < 0 ||\n    startRow >= matrix.rows ||\n    endRow < 0 ||\n    endRow >= matrix.rows ||\n    startColumn < 0 ||\n    startColumn >= matrix.columns ||\n    endColumn < 0 ||\n    endColumn >= matrix.columns\n  ) {\n    throw new RangeError('Submatrix indices are out of range');\n  }\n}\n\nexport function newArray(length, value = 0) {\n  let array = [];\n  for (let i = 0; i < length; i++) {\n    array.push(value);\n  }\n  return array;\n}\n\nfunction checkNumber(name, value) {\n  if (typeof value !== 'number') {\n    throw new TypeError(`${name} must be a number`);\n  }\n}\n","export function inspectMatrix() {\n  const indent = ' '.repeat(2);\n  const indentData = ' '.repeat(4);\n  return `${this.constructor.name} {\n${indent}[\n${indentData}${inspectData(this, indentData)}\n${indent}]\n${indent}rows: ${this.rows}\n${indent}columns: ${this.columns}\n}`;\n}\n\nconst maxRows = 15;\nconst maxColumns = 10;\nconst maxNumSize = 8;\n\nfunction inspectData(matrix, indent) {\n  const { rows, columns } = matrix;\n  const maxI = Math.min(rows, maxRows);\n  const maxJ = Math.min(columns, maxColumns);\n  const result = [];\n  for (let i = 0; i < maxI; i++) {\n    let line = [];\n    for (let j = 0; j < maxJ; j++) {\n      line.push(formatNumber(matrix.get(i, j)));\n    }\n    result.push(`${line.join(' ')}`);\n  }\n  if (maxJ !== columns) {\n    result[result.length - 1] += ` ... ${columns - maxColumns} more columns`;\n  }\n  if (maxI !== rows) {\n    result.push(`... ${rows - maxRows} more rows`);\n  }\n  return result.join(`\\n${indent}`);\n}\n\nfunction formatNumber(num) {\n  const numStr = String(num);\n  if (numStr.length <= maxNumSize) {\n    return numStr.padEnd(maxNumSize, ' ');\n  }\n  const precise = num.toPrecision(maxNumSize - 2);\n  if (precise.length <= maxNumSize) {\n    return precise;\n  }\n  const exponential = num.toExponential(maxNumSize - 2);\n  const eIndex = exponential.indexOf('e');\n  const e = exponential.substring(eIndex);\n  return exponential.substring(0, maxNumSize - e.length) + e;\n}\n","import rescale from 'ml-array-rescale';\n\nimport {\n  checkRowVector,\n  checkRowIndex,\n  checkColumnIndex,\n  checkColumnVector,\n  checkRange,\n  checkIndices,\n} from './util';\nimport {\n  sumByRow,\n  sumByColumn,\n  sumAll,\n  productByRow,\n  productByColumn,\n  productAll,\n  varianceByRow,\n  varianceByColumn,\n  varianceAll,\n  centerByRow,\n  centerByColumn,\n  centerAll,\n  scaleByRow,\n  scaleByColumn,\n  scaleAll,\n  getScaleByRow,\n  getScaleByColumn,\n  getScaleAll,\n} from './stat';\nimport { inspectMatrix } from './inspect';\nimport { installMathOperations } from './mathOperations';\n\nexport class AbstractMatrix {\n  static from1DArray(newRows, newColumns, newData) {\n    let length = newRows * newColumns;\n    if (length !== newData.length) {\n      throw new RangeError('data length does not match given dimensions');\n    }\n    let newMatrix = new Matrix(newRows, newColumns);\n    for (let row = 0; row < newRows; row++) {\n      for (let column = 0; column < newColumns; column++) {\n        newMatrix.set(row, column, newData[row * newColumns + column]);\n      }\n    }\n    return newMatrix;\n  }\n\n  static rowVector(newData) {\n    let vector = new Matrix(1, newData.length);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(0, i, newData[i]);\n    }\n    return vector;\n  }\n\n  static columnVector(newData) {\n    let vector = new Matrix(newData.length, 1);\n    for (let i = 0; i < newData.length; i++) {\n      vector.set(i, 0, newData[i]);\n    }\n    return vector;\n  }\n\n  static zeros(rows, columns) {\n    return new Matrix(rows, columns);\n  }\n\n  static ones(rows, columns) {\n    return new Matrix(rows, columns).fill(1);\n  }\n\n  static rand(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { random = Math.random } = options;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.set(i, j, random());\n      }\n    }\n    return matrix;\n  }\n\n  static randInt(rows, columns, options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1000, random = Math.random } = options;\n    if (!Number.isInteger(min)) throw new TypeError('min must be an integer');\n    if (!Number.isInteger(max)) throw new TypeError('max must be an integer');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let interval = max - min;\n    let matrix = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        let value = min + Math.round(random() * interval);\n        matrix.set(i, j, value);\n      }\n    }\n    return matrix;\n  }\n\n  static eye(rows, columns, value) {\n    if (columns === undefined) columns = rows;\n    if (value === undefined) value = 1;\n    let min = Math.min(rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, value);\n    }\n    return matrix;\n  }\n\n  static diag(data, rows, columns) {\n    let l = data.length;\n    if (rows === undefined) rows = l;\n    if (columns === undefined) columns = rows;\n    let min = Math.min(l, rows, columns);\n    let matrix = this.zeros(rows, columns);\n    for (let i = 0; i < min; i++) {\n      matrix.set(i, i, data[i]);\n    }\n    return matrix;\n  }\n\n  static min(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new Matrix(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.min(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static max(matrix1, matrix2) {\n    matrix1 = this.checkMatrix(matrix1);\n    matrix2 = this.checkMatrix(matrix2);\n    let rows = matrix1.rows;\n    let columns = matrix1.columns;\n    let result = new this(rows, columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        result.set(i, j, Math.max(matrix1.get(i, j), matrix2.get(i, j)));\n      }\n    }\n    return result;\n  }\n\n  static checkMatrix(value) {\n    return AbstractMatrix.isMatrix(value) ? value : new Matrix(value);\n  }\n\n  static isMatrix(value) {\n    return value != null && value.klass === 'Matrix';\n  }\n\n  get size() {\n    return this.rows * this.columns;\n  }\n\n  apply(callback) {\n    if (typeof callback !== 'function') {\n      throw new TypeError('callback must be a function');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        callback.call(this, i, j);\n      }\n    }\n    return this;\n  }\n\n  to1DArray() {\n    let array = [];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        array.push(this.get(i, j));\n      }\n    }\n    return array;\n  }\n\n  to2DArray() {\n    let copy = [];\n    for (let i = 0; i < this.rows; i++) {\n      copy.push([]);\n      for (let j = 0; j < this.columns; j++) {\n        copy[i].push(this.get(i, j));\n      }\n    }\n    return copy;\n  }\n\n  toJSON() {\n    return this.to2DArray();\n  }\n\n  isRowVector() {\n    return this.rows === 1;\n  }\n\n  isColumnVector() {\n    return this.columns === 1;\n  }\n\n  isVector() {\n    return this.rows === 1 || this.columns === 1;\n  }\n\n  isSquare() {\n    return this.rows === this.columns;\n  }\n\n  isSymmetric() {\n    if (this.isSquare()) {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j <= i; j++) {\n          if (this.get(i, j) !== this.get(j, i)) {\n            return false;\n          }\n        }\n      }\n      return true;\n    }\n    return false;\n  }\n\n  isEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isEchelonForm = false;\n          checked = true;\n        }\n      }\n      i++;\n    }\n    return isEchelonForm;\n  }\n\n  isReducedEchelonForm() {\n    let i = 0;\n    let j = 0;\n    let previousColumn = -1;\n    let isReducedEchelonForm = true;\n    let checked = false;\n    while (i < this.rows && isReducedEchelonForm) {\n      j = 0;\n      checked = false;\n      while (j < this.columns && checked === false) {\n        if (this.get(i, j) === 0) {\n          j++;\n        } else if (this.get(i, j) === 1 && j > previousColumn) {\n          checked = true;\n          previousColumn = j;\n        } else {\n          isReducedEchelonForm = false;\n          checked = true;\n        }\n      }\n      for (let k = j + 1; k < this.rows; k++) {\n        if (this.get(i, k) !== 0) {\n          isReducedEchelonForm = false;\n        }\n      }\n      i++;\n    }\n    return isReducedEchelonForm;\n  }\n\n  echelonForm() {\n    let result = this.clone();\n    let h = 0;\n    let k = 0;\n    while (h < result.rows && k < result.columns) {\n      let iMax = h;\n      for (let i = h; i < result.rows; i++) {\n        if (result.get(i, k) > result.get(iMax, k)) {\n          iMax = i;\n        }\n      }\n      if (result.get(iMax, k) === 0) {\n        k++;\n      } else {\n        result.swapRows(h, iMax);\n        let tmp = result.get(h, k);\n        for (let j = k; j < result.columns; j++) {\n          result.set(h, j, result.get(h, j) / tmp);\n        }\n        for (let i = h + 1; i < result.rows; i++) {\n          let factor = result.get(i, k) / result.get(h, k);\n          result.set(i, k, 0);\n          for (let j = k + 1; j < result.columns; j++) {\n            result.set(i, j, result.get(i, j) - result.get(h, j) * factor);\n          }\n        }\n        h++;\n        k++;\n      }\n    }\n    return result;\n  }\n\n  reducedEchelonForm() {\n    let result = this.echelonForm();\n    let m = result.columns;\n    let n = result.rows;\n    let h = n - 1;\n    while (h >= 0) {\n      if (result.maxRow(h) === 0) {\n        h--;\n      } else {\n        let p = 0;\n        let pivot = false;\n        while (p < n && pivot === false) {\n          if (result.get(h, p) === 1) {\n            pivot = true;\n          } else {\n            p++;\n          }\n        }\n        for (let i = 0; i < h; i++) {\n          let factor = result.get(i, p);\n          for (let j = p; j < m; j++) {\n            let tmp = result.get(i, j) - factor * result.get(h, j);\n            result.set(i, j, tmp);\n          }\n        }\n        h--;\n      }\n    }\n    return result;\n  }\n\n  set() {\n    throw new Error('set method is unimplemented');\n  }\n\n  get() {\n    throw new Error('get method is unimplemented');\n  }\n\n  repeat(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { rows = 1, columns = 1 } = options;\n    if (!Number.isInteger(rows) || rows <= 0) {\n      throw new TypeError('rows must be a positive integer');\n    }\n    if (!Number.isInteger(columns) || columns <= 0) {\n      throw new TypeError('columns must be a positive integer');\n    }\n    let matrix = new Matrix(this.rows * rows, this.columns * columns);\n    for (let i = 0; i < rows; i++) {\n      for (let j = 0; j < columns; j++) {\n        matrix.setSubMatrix(this, this.rows * i, this.columns * j);\n      }\n    }\n    return matrix;\n  }\n\n  fill(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, value);\n      }\n    }\n    return this;\n  }\n\n  neg() {\n    return this.mulS(-1);\n  }\n\n  getRow(index) {\n    checkRowIndex(this, index);\n    let row = [];\n    for (let i = 0; i < this.columns; i++) {\n      row.push(this.get(index, i));\n    }\n    return row;\n  }\n\n  getRowVector(index) {\n    return Matrix.rowVector(this.getRow(index));\n  }\n\n  setRow(index, array) {\n    checkRowIndex(this, index);\n    array = checkRowVector(this, array);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, array[i]);\n    }\n    return this;\n  }\n\n  swapRows(row1, row2) {\n    checkRowIndex(this, row1);\n    checkRowIndex(this, row2);\n    for (let i = 0; i < this.columns; i++) {\n      let temp = this.get(row1, i);\n      this.set(row1, i, this.get(row2, i));\n      this.set(row2, i, temp);\n    }\n    return this;\n  }\n\n  getColumn(index) {\n    checkColumnIndex(this, index);\n    let column = [];\n    for (let i = 0; i < this.rows; i++) {\n      column.push(this.get(i, index));\n    }\n    return column;\n  }\n\n  getColumnVector(index) {\n    return Matrix.columnVector(this.getColumn(index));\n  }\n\n  setColumn(index, array) {\n    checkColumnIndex(this, index);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, array[i]);\n    }\n    return this;\n  }\n\n  swapColumns(column1, column2) {\n    checkColumnIndex(this, column1);\n    checkColumnIndex(this, column2);\n    for (let i = 0; i < this.rows; i++) {\n      let temp = this.get(i, column1);\n      this.set(i, column1, this.get(i, column2));\n      this.set(i, column2, temp);\n    }\n    return this;\n  }\n\n  addRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[j]);\n      }\n    }\n    return this;\n  }\n\n  subRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[j]);\n      }\n    }\n    return this;\n  }\n\n  mulRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[j]);\n      }\n    }\n    return this;\n  }\n\n  divRowVector(vector) {\n    vector = checkRowVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[j]);\n      }\n    }\n    return this;\n  }\n\n  addColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + vector[i]);\n      }\n    }\n    return this;\n  }\n\n  subColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * vector[i]);\n      }\n    }\n    return this;\n  }\n\n  divColumnVector(vector) {\n    vector = checkColumnVector(this, vector);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / vector[i]);\n      }\n    }\n    return this;\n  }\n\n  mulRow(index, value) {\n    checkRowIndex(this, index);\n    for (let i = 0; i < this.columns; i++) {\n      this.set(index, i, this.get(index, i) * value);\n    }\n    return this;\n  }\n\n  mulColumn(index, value) {\n    checkColumnIndex(this, index);\n    for (let i = 0; i < this.rows; i++) {\n      this.set(i, index, this.get(i, index) * value);\n    }\n    return this;\n  }\n\n  max() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  maxIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) > v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  min() {\n    let v = this.get(0, 0);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n        }\n      }\n    }\n    return v;\n  }\n\n  minIndex() {\n    let v = this.get(0, 0);\n    let idx = [0, 0];\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        if (this.get(i, j) < v) {\n          v = this.get(i, j);\n          idx[0] = i;\n          idx[1] = j;\n        }\n      }\n    }\n    return idx;\n  }\n\n  maxRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  maxRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) > v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  minRow(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n      }\n    }\n    return v;\n  }\n\n  minRowIndex(row) {\n    checkRowIndex(this, row);\n    let v = this.get(row, 0);\n    let idx = [row, 0];\n    for (let i = 1; i < this.columns; i++) {\n      if (this.get(row, i) < v) {\n        v = this.get(row, i);\n        idx[1] = i;\n      }\n    }\n    return idx;\n  }\n\n  maxColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  maxColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) > v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  minColumn(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n      }\n    }\n    return v;\n  }\n\n  minColumnIndex(column) {\n    checkColumnIndex(this, column);\n    let v = this.get(0, column);\n    let idx = [0, column];\n    for (let i = 1; i < this.rows; i++) {\n      if (this.get(i, column) < v) {\n        v = this.get(i, column);\n        idx[0] = i;\n      }\n    }\n    return idx;\n  }\n\n  diag() {\n    let min = Math.min(this.rows, this.columns);\n    let diag = [];\n    for (let i = 0; i < min; i++) {\n      diag.push(this.get(i, i));\n    }\n    return diag;\n  }\n\n  norm(type = 'frobenius') {\n    let result = 0;\n    if (type === 'max') {\n      return this.max();\n    } else if (type === 'frobenius') {\n      for (let i = 0; i < this.rows; i++) {\n        for (let j = 0; j < this.columns; j++) {\n          result = result + this.get(i, j) * this.get(i, j);\n        }\n      }\n      return Math.sqrt(result);\n    } else {\n      throw new RangeError(`unknown norm type: ${type}`);\n    }\n  }\n\n  cumulativeSum() {\n    let sum = 0;\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        sum += this.get(i, j);\n        this.set(i, j, sum);\n      }\n    }\n    return this;\n  }\n\n  dot(vector2) {\n    if (AbstractMatrix.isMatrix(vector2)) vector2 = vector2.to1DArray();\n    let vector1 = this.to1DArray();\n    if (vector1.length !== vector2.length) {\n      throw new RangeError('vectors do not have the same size');\n    }\n    let dot = 0;\n    for (let i = 0; i < vector1.length; i++) {\n      dot += vector1[i] * vector2[i];\n    }\n    return dot;\n  }\n\n  mmul(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.columns;\n\n    let result = new Matrix(m, p);\n\n    let Bcolj = new Float64Array(n);\n    for (let j = 0; j < p; j++) {\n      for (let k = 0; k < n; k++) {\n        Bcolj[k] = other.get(k, j);\n      }\n\n      for (let i = 0; i < m; i++) {\n        let s = 0;\n        for (let k = 0; k < n; k++) {\n          s += this.get(i, k) * Bcolj[k];\n        }\n\n        result.set(i, j, s);\n      }\n    }\n    return result;\n  }\n\n  strassen2x2(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(2, 2);\n    const a11 = this.get(0, 0);\n    const b11 = other.get(0, 0);\n    const a12 = this.get(0, 1);\n    const b12 = other.get(0, 1);\n    const a21 = this.get(1, 0);\n    const b21 = other.get(1, 0);\n    const a22 = this.get(1, 1);\n    const b22 = other.get(1, 1);\n\n    // Compute intermediate values.\n    const m1 = (a11 + a22) * (b11 + b22);\n    const m2 = (a21 + a22) * b11;\n    const m3 = a11 * (b12 - b22);\n    const m4 = a22 * (b21 - b11);\n    const m5 = (a11 + a12) * b22;\n    const m6 = (a21 - a11) * (b11 + b12);\n    const m7 = (a12 - a22) * (b21 + b22);\n\n    // Combine intermediate values into the output.\n    const c00 = m1 + m4 - m5 + m7;\n    const c01 = m3 + m5;\n    const c10 = m2 + m4;\n    const c11 = m1 - m2 + m3 + m6;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    return result;\n  }\n\n  strassen3x3(other) {\n    other = Matrix.checkMatrix(other);\n    let result = new Matrix(3, 3);\n\n    const a00 = this.get(0, 0);\n    const a01 = this.get(0, 1);\n    const a02 = this.get(0, 2);\n    const a10 = this.get(1, 0);\n    const a11 = this.get(1, 1);\n    const a12 = this.get(1, 2);\n    const a20 = this.get(2, 0);\n    const a21 = this.get(2, 1);\n    const a22 = this.get(2, 2);\n\n    const b00 = other.get(0, 0);\n    const b01 = other.get(0, 1);\n    const b02 = other.get(0, 2);\n    const b10 = other.get(1, 0);\n    const b11 = other.get(1, 1);\n    const b12 = other.get(1, 2);\n    const b20 = other.get(2, 0);\n    const b21 = other.get(2, 1);\n    const b22 = other.get(2, 2);\n\n    const m1 = (a00 + a01 + a02 - a10 - a11 - a21 - a22) * b11;\n    const m2 = (a00 - a10) * (-b01 + b11);\n    const m3 = a11 * (-b00 + b01 + b10 - b11 - b12 - b20 + b22);\n    const m4 = (-a00 + a10 + a11) * (b00 - b01 + b11);\n    const m5 = (a10 + a11) * (-b00 + b01);\n    const m6 = a00 * b00;\n    const m7 = (-a00 + a20 + a21) * (b00 - b02 + b12);\n    const m8 = (-a00 + a20) * (b02 - b12);\n    const m9 = (a20 + a21) * (-b00 + b02);\n    const m10 = (a00 + a01 + a02 - a11 - a12 - a20 - a21) * b12;\n    const m11 = a21 * (-b00 + b02 + b10 - b11 - b12 - b20 + b21);\n    const m12 = (-a02 + a21 + a22) * (b11 + b20 - b21);\n    const m13 = (a02 - a22) * (b11 - b21);\n    const m14 = a02 * b20;\n    const m15 = (a21 + a22) * (-b20 + b21);\n    const m16 = (-a02 + a11 + a12) * (b12 + b20 - b22);\n    const m17 = (a02 - a12) * (b12 - b22);\n    const m18 = (a11 + a12) * (-b20 + b22);\n    const m19 = a01 * b10;\n    const m20 = a12 * b21;\n    const m21 = a10 * b02;\n    const m22 = a20 * b01;\n    const m23 = a22 * b22;\n\n    const c00 = m6 + m14 + m19;\n    const c01 = m1 + m4 + m5 + m6 + m12 + m14 + m15;\n    const c02 = m6 + m7 + m9 + m10 + m14 + m16 + m18;\n    const c10 = m2 + m3 + m4 + m6 + m14 + m16 + m17;\n    const c11 = m2 + m4 + m5 + m6 + m20;\n    const c12 = m14 + m16 + m17 + m18 + m21;\n    const c20 = m6 + m7 + m8 + m11 + m12 + m13 + m14;\n    const c21 = m12 + m13 + m14 + m15 + m22;\n    const c22 = m6 + m7 + m8 + m9 + m23;\n\n    result.set(0, 0, c00);\n    result.set(0, 1, c01);\n    result.set(0, 2, c02);\n    result.set(1, 0, c10);\n    result.set(1, 1, c11);\n    result.set(1, 2, c12);\n    result.set(2, 0, c20);\n    result.set(2, 1, c21);\n    result.set(2, 2, c22);\n    return result;\n  }\n\n  mmulStrassen(y) {\n    y = Matrix.checkMatrix(y);\n    let x = this.clone();\n    let r1 = x.rows;\n    let c1 = x.columns;\n    let r2 = y.rows;\n    let c2 = y.columns;\n    if (c1 !== r2) {\n      // eslint-disable-next-line no-console\n      console.warn(\n        `Multiplying ${r1} x ${c1} and ${r2} x ${c2} matrix: dimensions do not match.`,\n      );\n    }\n\n    // Put a matrix into the top left of a matrix of zeros.\n    // `rows` and `cols` are the dimensions of the output matrix.\n    function embed(mat, rows, cols) {\n      let r = mat.rows;\n      let c = mat.columns;\n      if (r === rows && c === cols) {\n        return mat;\n      } else {\n        let resultat = AbstractMatrix.zeros(rows, cols);\n        resultat = resultat.setSubMatrix(mat, 0, 0);\n        return resultat;\n      }\n    }\n\n    // Make sure both matrices are the same size.\n    // This is exclusively for simplicity:\n    // this algorithm can be implemented with matrices of different sizes.\n\n    let r = Math.max(r1, r2);\n    let c = Math.max(c1, c2);\n    x = embed(x, r, c);\n    y = embed(y, r, c);\n\n    // Our recursive multiplication function.\n    function blockMult(a, b, rows, cols) {\n      // For small matrices, resort to naive multiplication.\n      if (rows <= 512 || cols <= 512) {\n        return a.mmul(b); // a is equivalent to this\n      }\n\n      // Apply dynamic padding.\n      if (rows % 2 === 1 && cols % 2 === 1) {\n        a = embed(a, rows + 1, cols + 1);\n        b = embed(b, rows + 1, cols + 1);\n      } else if (rows % 2 === 1) {\n        a = embed(a, rows + 1, cols);\n        b = embed(b, rows + 1, cols);\n      } else if (cols % 2 === 1) {\n        a = embed(a, rows, cols + 1);\n        b = embed(b, rows, cols + 1);\n      }\n\n      let halfRows = parseInt(a.rows / 2, 10);\n      let halfCols = parseInt(a.columns / 2, 10);\n      // Subdivide input matrices.\n      let a11 = a.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n      let b11 = b.subMatrix(0, halfRows - 1, 0, halfCols - 1);\n\n      let a12 = a.subMatrix(0, halfRows - 1, halfCols, a.columns - 1);\n      let b12 = b.subMatrix(0, halfRows - 1, halfCols, b.columns - 1);\n\n      let a21 = a.subMatrix(halfRows, a.rows - 1, 0, halfCols - 1);\n      let b21 = b.subMatrix(halfRows, b.rows - 1, 0, halfCols - 1);\n\n      let a22 = a.subMatrix(halfRows, a.rows - 1, halfCols, a.columns - 1);\n      let b22 = b.subMatrix(halfRows, b.rows - 1, halfCols, b.columns - 1);\n\n      // Compute intermediate values.\n      let m1 = blockMult(\n        AbstractMatrix.add(a11, a22),\n        AbstractMatrix.add(b11, b22),\n        halfRows,\n        halfCols,\n      );\n      let m2 = blockMult(AbstractMatrix.add(a21, a22), b11, halfRows, halfCols);\n      let m3 = blockMult(a11, AbstractMatrix.sub(b12, b22), halfRows, halfCols);\n      let m4 = blockMult(a22, AbstractMatrix.sub(b21, b11), halfRows, halfCols);\n      let m5 = blockMult(AbstractMatrix.add(a11, a12), b22, halfRows, halfCols);\n      let m6 = blockMult(\n        AbstractMatrix.sub(a21, a11),\n        AbstractMatrix.add(b11, b12),\n        halfRows,\n        halfCols,\n      );\n      let m7 = blockMult(\n        AbstractMatrix.sub(a12, a22),\n        AbstractMatrix.add(b21, b22),\n        halfRows,\n        halfCols,\n      );\n\n      // Combine intermediate values into the output.\n      let c11 = AbstractMatrix.add(m1, m4);\n      c11.sub(m5);\n      c11.add(m7);\n      let c12 = AbstractMatrix.add(m3, m5);\n      let c21 = AbstractMatrix.add(m2, m4);\n      let c22 = AbstractMatrix.sub(m1, m2);\n      c22.add(m3);\n      c22.add(m6);\n\n      // Crop output to the desired size (undo dynamic padding).\n      let resultat = AbstractMatrix.zeros(2 * c11.rows, 2 * c11.columns);\n      resultat = resultat.setSubMatrix(c11, 0, 0);\n      resultat = resultat.setSubMatrix(c12, c11.rows, 0);\n      resultat = resultat.setSubMatrix(c21, 0, c11.columns);\n      resultat = resultat.setSubMatrix(c22, c11.rows, c11.columns);\n      return resultat.subMatrix(0, rows - 1, 0, cols - 1);\n    }\n    return blockMult(x, y, r, c);\n  }\n\n  scaleRows(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.rows; i++) {\n      const row = this.getRow(i);\n      rescale(row, { min, max, output: row });\n      newMatrix.setRow(i, row);\n    }\n    return newMatrix;\n  }\n\n  scaleColumns(options = {}) {\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { min = 0, max = 1 } = options;\n    if (!Number.isFinite(min)) throw new TypeError('min must be a number');\n    if (!Number.isFinite(max)) throw new TypeError('max must be a number');\n    if (min >= max) throw new RangeError('min must be smaller than max');\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let i = 0; i < this.columns; i++) {\n      const column = this.getColumn(i);\n      rescale(column, {\n        min: min,\n        max: max,\n        output: column,\n      });\n      newMatrix.setColumn(i, column);\n    }\n    return newMatrix;\n  }\n\n  flipRows() {\n    const middle = Math.ceil(this.columns / 2);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < middle; j++) {\n        let first = this.get(i, j);\n        let last = this.get(i, this.columns - 1 - j);\n        this.set(i, j, last);\n        this.set(i, this.columns - 1 - j, first);\n      }\n    }\n    return this;\n  }\n\n  flipColumns() {\n    const middle = Math.ceil(this.rows / 2);\n    for (let j = 0; j < this.columns; j++) {\n      for (let i = 0; i < middle; i++) {\n        let first = this.get(i, j);\n        let last = this.get(this.rows - 1 - i, j);\n        this.set(i, j, last);\n        this.set(this.rows - 1 - i, j, first);\n      }\n    }\n    return this;\n  }\n\n  kroneckerProduct(other) {\n    other = Matrix.checkMatrix(other);\n\n    let m = this.rows;\n    let n = this.columns;\n    let p = other.rows;\n    let q = other.columns;\n\n    let result = new Matrix(m * p, n * q);\n    for (let i = 0; i < m; i++) {\n      for (let j = 0; j < n; j++) {\n        for (let k = 0; k < p; k++) {\n          for (let l = 0; l < q; l++) {\n            result.set(p * i + k, q * j + l, this.get(i, j) * other.get(k, l));\n          }\n        }\n      }\n    }\n    return result;\n  }\n\n  transpose() {\n    let result = new Matrix(this.columns, this.rows);\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        result.set(j, i, this.get(i, j));\n      }\n    }\n    return result;\n  }\n\n  sortRows(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.rows; i++) {\n      this.setRow(i, this.getRow(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  sortColumns(compareFunction = compareNumbers) {\n    for (let i = 0; i < this.columns; i++) {\n      this.setColumn(i, this.getColumn(i).sort(compareFunction));\n    }\n    return this;\n  }\n\n  subMatrix(startRow, endRow, startColumn, endColumn) {\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    let newMatrix = new Matrix(\n      endRow - startRow + 1,\n      endColumn - startColumn + 1,\n    );\n    for (let i = startRow; i <= endRow; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        newMatrix.set(i - startRow, j - startColumn, this.get(i, j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixRow(indices, startColumn, endColumn) {\n    if (startColumn === undefined) startColumn = 0;\n    if (endColumn === undefined) endColumn = this.columns - 1;\n    if (\n      startColumn > endColumn ||\n      startColumn < 0 ||\n      startColumn >= this.columns ||\n      endColumn < 0 ||\n      endColumn >= this.columns\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(indices.length, endColumn - startColumn + 1);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startColumn; j <= endColumn; j++) {\n        if (indices[i] < 0 || indices[i] >= this.rows) {\n          throw new RangeError(`Row index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(i, j - startColumn, this.get(indices[i], j));\n      }\n    }\n    return newMatrix;\n  }\n\n  subMatrixColumn(indices, startRow, endRow) {\n    if (startRow === undefined) startRow = 0;\n    if (endRow === undefined) endRow = this.rows - 1;\n    if (\n      startRow > endRow ||\n      startRow < 0 ||\n      startRow >= this.rows ||\n      endRow < 0 ||\n      endRow >= this.rows\n    ) {\n      throw new RangeError('Argument out of range');\n    }\n\n    let newMatrix = new Matrix(endRow - startRow + 1, indices.length);\n    for (let i = 0; i < indices.length; i++) {\n      for (let j = startRow; j <= endRow; j++) {\n        if (indices[i] < 0 || indices[i] >= this.columns) {\n          throw new RangeError(`Column index out of range: ${indices[i]}`);\n        }\n        newMatrix.set(j - startRow, i, this.get(j, indices[i]));\n      }\n    }\n    return newMatrix;\n  }\n\n  setSubMatrix(matrix, startRow, startColumn) {\n    matrix = Matrix.checkMatrix(matrix);\n    let endRow = startRow + matrix.rows - 1;\n    let endColumn = startColumn + matrix.columns - 1;\n    checkRange(this, startRow, endRow, startColumn, endColumn);\n    for (let i = 0; i < matrix.rows; i++) {\n      for (let j = 0; j < matrix.columns; j++) {\n        this.set(startRow + i, startColumn + j, matrix.get(i, j));\n      }\n    }\n    return this;\n  }\n\n  selection(rowIndices, columnIndices) {\n    let indices = checkIndices(this, rowIndices, columnIndices);\n    let newMatrix = new Matrix(rowIndices.length, columnIndices.length);\n    for (let i = 0; i < indices.row.length; i++) {\n      let rowIndex = indices.row[i];\n      for (let j = 0; j < indices.column.length; j++) {\n        let columnIndex = indices.column[j];\n        newMatrix.set(i, j, this.get(rowIndex, columnIndex));\n      }\n    }\n    return newMatrix;\n  }\n\n  trace() {\n    let min = Math.min(this.rows, this.columns);\n    let trace = 0;\n    for (let i = 0; i < min; i++) {\n      trace += this.get(i, i);\n    }\n    return trace;\n  }\n\n  clone() {\n    let newMatrix = new Matrix(this.rows, this.columns);\n    for (let row = 0; row < this.rows; row++) {\n      for (let column = 0; column < this.columns; column++) {\n        newMatrix.set(row, column, this.get(row, column));\n      }\n    }\n    return newMatrix;\n  }\n\n  sum(by) {\n    switch (by) {\n      case 'row':\n        return sumByRow(this);\n      case 'column':\n        return sumByColumn(this);\n      case undefined:\n        return sumAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  product(by) {\n    switch (by) {\n      case 'row':\n        return productByRow(this);\n      case 'column':\n        return productByColumn(this);\n      case undefined:\n        return productAll(this);\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  mean(by) {\n    const sum = this.sum(by);\n    switch (by) {\n      case 'row': {\n        for (let i = 0; i < this.rows; i++) {\n          sum[i] /= this.columns;\n        }\n        return sum;\n      }\n      case 'column': {\n        for (let i = 0; i < this.columns; i++) {\n          sum[i] /= this.rows;\n        }\n        return sum;\n      }\n      case undefined:\n        return sum / this.size;\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  variance(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { unbiased = true, mean = this.mean(by) } = options;\n    if (typeof unbiased !== 'boolean') {\n      throw new TypeError('unbiased must be a boolean');\n    }\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByRow(this, unbiased, mean);\n      }\n      case 'column': {\n        if (!Array.isArray(mean)) {\n          throw new TypeError('mean must be an array');\n        }\n        return varianceByColumn(this, unbiased, mean);\n      }\n      case undefined: {\n        if (typeof mean !== 'number') {\n          throw new TypeError('mean must be a number');\n        }\n        return varianceAll(this, unbiased, mean);\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  standardDeviation(by, options) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    const variance = this.variance(by, options);\n    if (by === undefined) {\n      return Math.sqrt(variance);\n    } else {\n      for (let i = 0; i < variance.length; i++) {\n        variance[i] = Math.sqrt(variance[i]);\n      }\n      return variance;\n    }\n  }\n\n  center(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    const { center = this.mean(by) } = options;\n    switch (by) {\n      case 'row': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByRow(this, center);\n        return this;\n      }\n      case 'column': {\n        if (!Array.isArray(center)) {\n          throw new TypeError('center must be an array');\n        }\n        centerByColumn(this, center);\n        return this;\n      }\n      case undefined: {\n        if (typeof center !== 'number') {\n          throw new TypeError('center must be a number');\n        }\n        centerAll(this, center);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n\n  scale(by, options = {}) {\n    if (typeof by === 'object') {\n      options = by;\n      by = undefined;\n    }\n    if (typeof options !== 'object') {\n      throw new TypeError('options must be an object');\n    }\n    let scale = options.scale;\n    switch (by) {\n      case 'row': {\n        if (scale === undefined) {\n          scale = getScaleByRow(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByRow(this, scale);\n        return this;\n      }\n      case 'column': {\n        if (scale === undefined) {\n          scale = getScaleByColumn(this);\n        } else if (!Array.isArray(scale)) {\n          throw new TypeError('scale must be an array');\n        }\n        scaleByColumn(this, scale);\n        return this;\n      }\n      case undefined: {\n        if (scale === undefined) {\n          scale = getScaleAll(this);\n        } else if (typeof scale !== 'number') {\n          throw new TypeError('scale must be a number');\n        }\n        scaleAll(this, scale);\n        return this;\n      }\n      default:\n        throw new Error(`invalid option: ${by}`);\n    }\n  }\n}\n\nAbstractMatrix.prototype.klass = 'Matrix';\nif (typeof Symbol !== 'undefined') {\n  AbstractMatrix.prototype[\n    Symbol.for('nodejs.util.inspect.custom')\n  ] = inspectMatrix;\n}\n\nfunction compareNumbers(a, b) {\n  return a - b;\n}\n\n// Synonyms\nAbstractMatrix.random = AbstractMatrix.rand;\nAbstractMatrix.randomInt = AbstractMatrix.randInt;\nAbstractMatrix.diagonal = AbstractMatrix.diag;\nAbstractMatrix.prototype.diagonal = AbstractMatrix.prototype.diag;\nAbstractMatrix.identity = AbstractMatrix.eye;\nAbstractMatrix.prototype.negate = AbstractMatrix.prototype.neg;\nAbstractMatrix.prototype.tensorProduct =\n  AbstractMatrix.prototype.kroneckerProduct;\n\nexport default class Matrix extends AbstractMatrix {\n  constructor(nRows, nColumns) {\n    super();\n    if (Matrix.isMatrix(nRows)) {\n      return nRows.clone();\n    } else if (Number.isInteger(nRows) && nRows > 0) {\n      // Create an empty matrix\n      this.data = [];\n      if (Number.isInteger(nColumns) && nColumns > 0) {\n        for (let i = 0; i < nRows; i++) {\n          this.data.push(new Float64Array(nColumns));\n        }\n      } else {\n        throw new TypeError('nColumns must be a positive integer');\n      }\n    } else if (Array.isArray(nRows)) {\n      // Copy the values from the 2D array\n      const arrayData = nRows;\n      nRows = arrayData.length;\n      nColumns = arrayData[0].length;\n      if (typeof nColumns !== 'number' || nColumns === 0) {\n        throw new TypeError(\n          'Data must be a 2D array with at least one element',\n        );\n      }\n      this.data = [];\n      for (let i = 0; i < nRows; i++) {\n        if (arrayData[i].length !== nColumns) {\n          throw new RangeError('Inconsistent array dimensions');\n        }\n        this.data.push(Float64Array.from(arrayData[i]));\n      }\n    } else {\n      throw new TypeError(\n        'First argument must be a positive number or an array',\n      );\n    }\n    this.rows = nRows;\n    this.columns = nColumns;\n    return this;\n  }\n\n  set(rowIndex, columnIndex, value) {\n    this.data[rowIndex][columnIndex] = value;\n    return this;\n  }\n\n  get(rowIndex, columnIndex) {\n    return this.data[rowIndex][columnIndex];\n  }\n\n  removeRow(index) {\n    checkRowIndex(this, index);\n    if (this.rows === 1) {\n      throw new RangeError('A matrix cannot have less than one row');\n    }\n    this.data.splice(index, 1);\n    this.rows -= 1;\n    return this;\n  }\n\n  addRow(index, array) {\n    if (array === undefined) {\n      array = index;\n      index = this.rows;\n    }\n    checkRowIndex(this, index, true);\n    array = Float64Array.from(checkRowVector(this, array, true));\n    this.data.splice(index, 0, array);\n    this.rows += 1;\n    return this;\n  }\n\n  removeColumn(index) {\n    checkColumnIndex(this, index);\n    if (this.columns === 1) {\n      throw new RangeError('A matrix cannot have less than one column');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns - 1);\n      for (let j = 0; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      for (let j = index + 1; j < this.columns; j++) {\n        newRow[j - 1] = this.data[i][j];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns -= 1;\n    return this;\n  }\n\n  addColumn(index, array) {\n    if (typeof array === 'undefined') {\n      array = index;\n      index = this.columns;\n    }\n    checkColumnIndex(this, index, true);\n    array = checkColumnVector(this, array);\n    for (let i = 0; i < this.rows; i++) {\n      const newRow = new Float64Array(this.columns + 1);\n      let j = 0;\n      for (; j < index; j++) {\n        newRow[j] = this.data[i][j];\n      }\n      newRow[j++] = array[i];\n      for (; j < this.columns + 1; j++) {\n        newRow[j] = this.data[i][j - 1];\n      }\n      this.data[i] = newRow;\n    }\n    this.columns += 1;\n    return this;\n  }\n}\n\ninstallMathOperations(AbstractMatrix, Matrix);\n","import { newArray } from './util';\n\nexport function sumByRow(matrix) {\n  let sum = newArray(matrix.rows);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumByColumn(matrix) {\n  let sum = newArray(matrix.columns);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] += matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function sumAll(matrix) {\n  let v = 0;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v += matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function productByRow(matrix) {\n  let sum = newArray(matrix.rows, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[i] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productByColumn(matrix) {\n  let sum = newArray(matrix.columns, 1);\n  for (let i = 0; i < matrix.rows; ++i) {\n    for (let j = 0; j < matrix.columns; ++j) {\n      sum[j] *= matrix.get(i, j);\n    }\n  }\n  return sum;\n}\n\nexport function productAll(matrix) {\n  let v = 1;\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      v *= matrix.get(i, j);\n    }\n  }\n  return v;\n}\n\nexport function varianceByRow(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let i = 0; i < rows; i++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean[i];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / cols) / (cols - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / cols) / cols);\n    }\n  }\n  return variance;\n}\n\nexport function varianceByColumn(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const variance = [];\n\n  for (let j = 0; j < cols; j++) {\n    let sum1 = 0;\n    let sum2 = 0;\n    let x = 0;\n    for (let i = 0; i < rows; i++) {\n      x = matrix.get(i, j) - mean[j];\n      sum1 += x;\n      sum2 += x * x;\n    }\n    if (unbiased) {\n      variance.push((sum2 - (sum1 * sum1) / rows) / (rows - 1));\n    } else {\n      variance.push((sum2 - (sum1 * sum1) / rows) / rows);\n    }\n  }\n  return variance;\n}\n\nexport function varianceAll(matrix, unbiased, mean) {\n  const rows = matrix.rows;\n  const cols = matrix.columns;\n  const size = rows * cols;\n\n  let sum1 = 0;\n  let sum2 = 0;\n  let x = 0;\n  for (let i = 0; i < rows; i++) {\n    for (let j = 0; j < cols; j++) {\n      x = matrix.get(i, j) - mean;\n      sum1 += x;\n      sum2 += x * x;\n    }\n  }\n  if (unbiased) {\n    return (sum2 - (sum1 * sum1) / size) / (size - 1);\n  } else {\n    return (sum2 - (sum1 * sum1) / size) / size;\n  }\n}\n\nexport function centerByRow(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[i]);\n    }\n  }\n}\n\nexport function centerByColumn(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean[j]);\n    }\n  }\n}\n\nexport function centerAll(matrix, mean) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) - mean);\n    }\n  }\n}\n\nexport function getScaleByRow(matrix) {\n  const scale = [];\n  for (let i = 0; i < matrix.rows; i++) {\n    let sum = 0;\n    for (let j = 0; j < matrix.columns; j++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.columns - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByRow(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[i]);\n    }\n  }\n}\n\nexport function getScaleByColumn(matrix) {\n  const scale = [];\n  for (let j = 0; j < matrix.columns; j++) {\n    let sum = 0;\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / (matrix.rows - 1);\n    }\n    scale.push(Math.sqrt(sum));\n  }\n  return scale;\n}\n\nexport function scaleByColumn(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale[j]);\n    }\n  }\n}\n\nexport function getScaleAll(matrix) {\n  const divider = matrix.size - 1;\n  let sum = 0;\n  for (let j = 0; j < matrix.columns; j++) {\n    for (let i = 0; i < matrix.rows; i++) {\n      sum += Math.pow(matrix.get(i, j), 2) / divider;\n    }\n  }\n  return Math.sqrt(sum);\n}\n\nexport function scaleAll(matrix, scale) {\n  for (let i = 0; i < matrix.rows; i++) {\n    for (let j = 0; j < matrix.columns; j++) {\n      matrix.set(i, j, matrix.get(i, j) / scale);\n    }\n  }\n}\n","import floydWarshall from 'ml-floyd-warshall';\nimport { Matrix } from 'ml-matrix';\n\nimport { getOCL } from '../OCL';\n\n/**\n * Returns a connectivity matrix\n * @param {OCL.Molecule} molecule\n * @param {object} [options={}]\n * @param {boolean} [options.pathLength=false] get the path length between atoms\n * @param {boolean} [options.mass=false] set the nominal mass of the atoms on diagonal\n * @param {boolean} [options.atomicNo=false] set the atomic number of the atom on diagonal\n * @param {boolean} [options.sdt=false] set 1, 2 or 3 depending if single, double or triple bond\n */\nexport function getConnectivityMatrix(molecule, options = {}) {\n  const OCL = getOCL();\n  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);\n  let nbAtoms = molecule.getAllAtoms();\n\n  let result = new Array(nbAtoms).fill();\n  result = result.map(() => new Array(nbAtoms).fill(0));\n\n  if (!options.pathLength) {\n    if (options.atomicNo) {\n      for (let i = 0; i < nbAtoms; i++) {\n        result[i][i] = molecule.getAtomicNo(i);\n      }\n    } else if (options.mass) {\n      for (let i = 0; i < nbAtoms; i++) {\n        result[i][i] = OCL.Molecule.cRoundedMass[molecule.getAtomicNo(i)];\n      }\n    } else {\n      for (let i = 0; i < nbAtoms; i++) {\n        result[i][i] = 1;\n      }\n    }\n  }\n\n  if (options.sdt) {\n    for (let i = 0; i < nbAtoms; i++) {\n      let l = molecule.getAllConnAtoms(i);\n      for (let j = 0; j < l; j++) {\n        result[i][molecule.getConnAtom(i, j)] = molecule.getConnBondOrder(i, j);\n      }\n    }\n  } else {\n    for (let i = 0; i < nbAtoms; i++) {\n      let l = molecule.getAllConnAtoms(i);\n      for (let j = 0; j < l; j++) {\n        result[i][molecule.getConnAtom(i, j)] = 1;\n      }\n    }\n  }\n\n  if (options.pathLength) {\n    result = floydWarshall(new Matrix(result)).to2DArray();\n  }\n  return result;\n}\n","import { Matrix } from 'ml-matrix';\n\n/**\n * Algorithm that finds the shortest distance from one node to the other\n * @param {Matrix} adjMatrix - A squared adjacency matrix\n * @return {Matrix} - Distance from a node to the other, -1 if the node is unreachable\n */\nexport default function floydWarshall(adjMatrix) {\n  if (Matrix.isMatrix(adjMatrix) && adjMatrix.columns !== adjMatrix.rows) {\n    throw new TypeError('The adjacency matrix should be squared');\n  }\n  const numVertices = adjMatrix.columns;\n  let distMatrix = new Matrix(numVertices, numVertices);\n  distMatrix.apply((row, column) => {\n    // principal diagonal is 0\n    if (row === column) {\n      distMatrix.set(row, column, 0);\n    } else {\n      let val = adjMatrix.get(row, column);\n\n      if (val) {\n        // edges values remain the same\n        distMatrix.set(row, column, val);\n      } else {\n        // 0 values become infinity\n        distMatrix.set(row, column, Number.POSITIVE_INFINITY);\n      }\n    }\n  });\n\n  for (let k = 0; k < numVertices; ++k) {\n    for (let i = 0; i < numVertices; ++i) {\n      for (let j = 0; j < numVertices; ++j) {\n        let dist = distMatrix.get(i, k) + distMatrix.get(k, j);\n        if (distMatrix.get(i, j) > dist) {\n          distMatrix.set(i, j, dist);\n        }\n      }\n    }\n  }\n\n  // When there's no connection the value is -1\n  distMatrix.apply((row, column) => {\n    if (distMatrix.get(row, column) === Number.POSITIVE_INFINITY) {\n      distMatrix.set(row, column, -1);\n    }\n  });\n  return distMatrix;\n}\n","import { tagAtom } from '../util/tagAtom';\nimport { getOCL } from '../OCL';\nimport { makeRacemic } from '../util/makeRacemic';\n\nlet fragment;\n\n/**\n * Returns the hose code for a specific atom number\n * @param {OCL.Molecule} molecule\n */\nexport function getHoseCodesForPath(molecule, from, to, maxLength) {\n  const OCL = getOCL();\n  const originalFrom = from;\n  const originalTo = to;\n  molecule = molecule.getCompactCopy();\n\n  let originalAtoms = []; // path before renumbering\n  molecule.getPath(originalAtoms, from, to, maxLength + 1);\n  let torsion;\n  if (originalAtoms.length === 4) {\n    torsion = molecule.calculateTorsion(originalAtoms);\n  }\n\n  const tag1 = tagAtom(molecule, from);\n  const tag2 = tagAtom(molecule, to);\n\n  molecule.addImplicitHydrogens();\n  molecule.addMissingChirality();\n\n  molecule.ensureHelperArrays(OCL.Molecule.cHelperNeighbours);\n\n  from = -1;\n  to = -1;\n  for (let i = 0; i < molecule.getAllAtoms(); i++) {\n    if (tag1 === tag2) {\n      if (molecule.getAtomCustomLabel(i) === tag1) {\n        if (from === -1) {\n          from = i;\n        } else {\n          to = i;\n        }\n      }\n    } else {\n      if (tag1 === molecule.getAtomCustomLabel(i)) {\n        from = i;\n      }\n      if (tag2 === molecule.getAtomCustomLabel(i)) {\n        to = i;\n      }\n    }\n  }\n\n  if (!fragment) fragment = new OCL.Molecule(0, 0);\n\n  let atoms = [];\n  molecule.getPath(atoms, from, to, maxLength + 1);\n\n  let min = 0;\n  let max = 0;\n  let atomMask = new Array(molecule.getAllAtoms()).fill(false);\n  let atomList = new Array(molecule.getAllAtoms()).fill(-1);\n  let hoses = [];\n\n  for (let sphere = 0; sphere <= 2; sphere++) {\n    if (max === 0) {\n      for (let atom of atoms) {\n        atomMask[atom] = true;\n        atomList[max++] = atom;\n      }\n    } else {\n      let newMax = max;\n      for (let i = min; i < max; i++) {\n        let atom = atomList[i];\n        for (let j = 0; j < molecule.getAllConnAtoms(atom); j++) {\n          let connAtom = molecule.getConnAtom(atom, j);\n          if (!atomMask[connAtom]) {\n            atomMask[connAtom] = true;\n            atomList[newMax++] = connAtom;\n          }\n        }\n      }\n      min = max;\n      max = newMax;\n    }\n    let atomMap = [];\n\n    molecule.copyMoleculeByAtoms(fragment, atomMask, true, atomMap);\n    makeRacemic(fragment);\n    let oclID = fragment.getCanonizedIDCode(\n      OCL.Molecule.CANONIZER_ENCODE_ATOM_CUSTOM_LABELS,\n    );\n\n    hoses.push({\n      sphere,\n      oclID,\n    });\n  }\n\n  return {\n    atoms: originalAtoms,\n    from: originalFrom,\n    to: originalTo,\n    torsion,\n    hoses,\n    length: originalAtoms.length - 1,\n  };\n}\n","import { getConnectivityMatrix } from '../util/getConnectivityMatrix';\nimport { getAtomsInfo } from '../util/getAtomsInfo';\nimport { getOCL } from '../OCL';\nimport { getHoseCodesForPath } from '../hose/getHoseCodesForPath';\n\nlet fragment;\n\n/**\n *\n * @param {OCL.Molecule} molecule\n * @param {object} [options={}]\n * @param {string} [opions.fromLabel='H']\n * @param {string} [opions.toLabel='H']\n * @param {string} [opions.minLenght=1]\n * @param {string} [opions.maxLength=4]\n\n */\nexport function getPathsInfo(molecule, options = {}) {\n  const {\n    fromLabel = 'H',\n    toLabel = 'H',\n    minLength = 1,\n    maxLength = 4,\n  } = options;\n\n  const OCL = getOCL();\n\n  if (!fragment) {\n    fragment = new OCL.Molecule(0, 0);\n  }\n\n  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);\n  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);\n\n  // we need to find all the atoms 'fromLabel' and 'toLabel'\n  let atomsInfo = getAtomsInfo(molecule);\n\n  let pathLengthMatrix = getConnectivityMatrix(molecule, {\n    pathLength: true,\n  });\n\n  for (let from = 0; from < molecule.getAllAtoms(); from++) {\n    atomsInfo[from].paths = [];\n    for (let to = 0; to < molecule.getAllAtoms(); to++) {\n      if (from !== to) {\n        if (molecule.getAtomicNo(from) === fromAtomicNumber) {\n          if (molecule.getAtomicNo(to) === toAtomicNumber) {\n            let pathLength = pathLengthMatrix[from][to];\n            if (pathLength >= minLength && pathLength <= maxLength) {\n              atomsInfo[from].paths.push(\n                getHoseCodesForPath(\n                  molecule,\n                  from,\n                  to,\n                  pathLength,\n                  atomsInfo[to].oclID,\n                ),\n              );\n            }\n          }\n        }\n      }\n    }\n  }\n\n  return atomsInfo;\n}\n","export function installMathOperations(AbstractMatrix, Matrix) {\n  AbstractMatrix.prototype.add = function add(value) {\n    if (typeof value === 'number') return this.addS(value);\n    return this.addM(value);\n  };\n\n  AbstractMatrix.prototype.addS = function addS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.addM = function addM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) + matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.add = function add(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.add(value);\n  };\n\n  AbstractMatrix.prototype.sub = function sub(value) {\n    if (typeof value === 'number') return this.subS(value);\n    return this.subM(value);\n  };\n\n  AbstractMatrix.prototype.subS = function subS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.subM = function subM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) - matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sub = function sub(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sub(value);\n  };\n  AbstractMatrix.prototype.subtract = AbstractMatrix.prototype.sub;\n  AbstractMatrix.prototype.subtractS = AbstractMatrix.prototype.subS;\n  AbstractMatrix.prototype.subtractM = AbstractMatrix.prototype.subM;\n  AbstractMatrix.subtract = AbstractMatrix.sub;\n\n  AbstractMatrix.prototype.mul = function mul(value) {\n    if (typeof value === 'number') return this.mulS(value);\n    return this.mulM(value);\n  };\n\n  AbstractMatrix.prototype.mulS = function mulS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.mulM = function mulM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) * matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mul = function mul(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mul(value);\n  };\n  AbstractMatrix.prototype.multiply = AbstractMatrix.prototype.mul;\n  AbstractMatrix.prototype.multiplyS = AbstractMatrix.prototype.mulS;\n  AbstractMatrix.prototype.multiplyM = AbstractMatrix.prototype.mulM;\n  AbstractMatrix.multiply = AbstractMatrix.mul;\n\n  AbstractMatrix.prototype.div = function div(value) {\n    if (typeof value === 'number') return this.divS(value);\n    return this.divM(value);\n  };\n\n  AbstractMatrix.prototype.divS = function divS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.divM = function divM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) / matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.div = function div(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.div(value);\n  };\n  AbstractMatrix.prototype.divide = AbstractMatrix.prototype.div;\n  AbstractMatrix.prototype.divideS = AbstractMatrix.prototype.divS;\n  AbstractMatrix.prototype.divideM = AbstractMatrix.prototype.divM;\n  AbstractMatrix.divide = AbstractMatrix.div;\n\n  AbstractMatrix.prototype.mod = function mod(value) {\n    if (typeof value === 'number') return this.modS(value);\n    return this.modM(value);\n  };\n\n  AbstractMatrix.prototype.modS = function modS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.modM = function modM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) % matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.mod = function mod(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.mod(value);\n  };\n  AbstractMatrix.prototype.modulus = AbstractMatrix.prototype.mod;\n  AbstractMatrix.prototype.modulusS = AbstractMatrix.prototype.modS;\n  AbstractMatrix.prototype.modulusM = AbstractMatrix.prototype.modM;\n  AbstractMatrix.modulus = AbstractMatrix.mod;\n\n  AbstractMatrix.prototype.and = function and(value) {\n    if (typeof value === 'number') return this.andS(value);\n    return this.andM(value);\n  };\n\n  AbstractMatrix.prototype.andS = function andS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.andM = function andM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) & matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.and = function and(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.and(value);\n  };\n\n  AbstractMatrix.prototype.or = function or(value) {\n    if (typeof value === 'number') return this.orS(value);\n    return this.orM(value);\n  };\n\n  AbstractMatrix.prototype.orS = function orS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.orM = function orM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) | matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.or = function or(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.or(value);\n  };\n\n  AbstractMatrix.prototype.xor = function xor(value) {\n    if (typeof value === 'number') return this.xorS(value);\n    return this.xorM(value);\n  };\n\n  AbstractMatrix.prototype.xorS = function xorS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.xorM = function xorM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) ^ matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.xor = function xor(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.xor(value);\n  };\n\n  AbstractMatrix.prototype.leftShift = function leftShift(value) {\n    if (typeof value === 'number') return this.leftShiftS(value);\n    return this.leftShiftM(value);\n  };\n\n  AbstractMatrix.prototype.leftShiftS = function leftShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.leftShiftM = function leftShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) << matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.leftShift = function leftShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.leftShift(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShift = function signPropagatingRightShift(value) {\n    if (typeof value === 'number') return this.signPropagatingRightShiftS(value);\n    return this.signPropagatingRightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftS = function signPropagatingRightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.signPropagatingRightShiftM = function signPropagatingRightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.signPropagatingRightShift = function signPropagatingRightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.signPropagatingRightShift(value);\n  };\n\n  AbstractMatrix.prototype.rightShift = function rightShift(value) {\n    if (typeof value === 'number') return this.rightShiftS(value);\n    return this.rightShiftM(value);\n  };\n\n  AbstractMatrix.prototype.rightShiftS = function rightShiftS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> value);\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.rightShiftM = function rightShiftM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, this.get(i, j) >>> matrix.get(i, j));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.rightShift = function rightShift(matrix, value) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.rightShift(value);\n  };\n  AbstractMatrix.prototype.zeroFillRightShift = AbstractMatrix.prototype.rightShift;\n  AbstractMatrix.prototype.zeroFillRightShiftS = AbstractMatrix.prototype.rightShiftS;\n  AbstractMatrix.prototype.zeroFillRightShiftM = AbstractMatrix.prototype.rightShiftM;\n  AbstractMatrix.zeroFillRightShift = AbstractMatrix.rightShift;\n\n  AbstractMatrix.prototype.not = function not() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, ~(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.not = function not(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.not();\n  };\n\n  AbstractMatrix.prototype.abs = function abs() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.abs(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.abs = function abs(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.abs();\n  };\n\n  AbstractMatrix.prototype.acos = function acos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acos = function acos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acos();\n  };\n\n  AbstractMatrix.prototype.acosh = function acosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.acosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.acosh = function acosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.acosh();\n  };\n\n  AbstractMatrix.prototype.asin = function asin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asin = function asin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asin();\n  };\n\n  AbstractMatrix.prototype.asinh = function asinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.asinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.asinh = function asinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.asinh();\n  };\n\n  AbstractMatrix.prototype.atan = function atan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atan = function atan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atan();\n  };\n\n  AbstractMatrix.prototype.atanh = function atanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.atanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.atanh = function atanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.atanh();\n  };\n\n  AbstractMatrix.prototype.cbrt = function cbrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cbrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cbrt = function cbrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cbrt();\n  };\n\n  AbstractMatrix.prototype.ceil = function ceil() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.ceil(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.ceil = function ceil(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.ceil();\n  };\n\n  AbstractMatrix.prototype.clz32 = function clz32() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.clz32(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.clz32 = function clz32(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.clz32();\n  };\n\n  AbstractMatrix.prototype.cos = function cos() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cos(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cos = function cos(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cos();\n  };\n\n  AbstractMatrix.prototype.cosh = function cosh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.cosh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.cosh = function cosh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.cosh();\n  };\n\n  AbstractMatrix.prototype.exp = function exp() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.exp(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.exp = function exp(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.exp();\n  };\n\n  AbstractMatrix.prototype.expm1 = function expm1() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.expm1(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.expm1 = function expm1(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.expm1();\n  };\n\n  AbstractMatrix.prototype.floor = function floor() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.floor(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.floor = function floor(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.floor();\n  };\n\n  AbstractMatrix.prototype.fround = function fround() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.fround(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.fround = function fround(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.fround();\n  };\n\n  AbstractMatrix.prototype.log = function log() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log = function log(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log();\n  };\n\n  AbstractMatrix.prototype.log1p = function log1p() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log1p(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log1p = function log1p(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log1p();\n  };\n\n  AbstractMatrix.prototype.log10 = function log10() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log10(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log10 = function log10(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log10();\n  };\n\n  AbstractMatrix.prototype.log2 = function log2() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.log2(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.log2 = function log2(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.log2();\n  };\n\n  AbstractMatrix.prototype.round = function round() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.round(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.round = function round(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.round();\n  };\n\n  AbstractMatrix.prototype.sign = function sign() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sign(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sign = function sign(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sign();\n  };\n\n  AbstractMatrix.prototype.sin = function sin() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sin(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sin = function sin(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sin();\n  };\n\n  AbstractMatrix.prototype.sinh = function sinh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sinh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sinh = function sinh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sinh();\n  };\n\n  AbstractMatrix.prototype.sqrt = function sqrt() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.sqrt(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.sqrt = function sqrt(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.sqrt();\n  };\n\n  AbstractMatrix.prototype.tan = function tan() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tan(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tan = function tan(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tan();\n  };\n\n  AbstractMatrix.prototype.tanh = function tanh() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.tanh(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.tanh = function tanh(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.tanh();\n  };\n\n  AbstractMatrix.prototype.trunc = function trunc() {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.trunc(this.get(i, j)));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.trunc = function trunc(matrix) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.trunc();\n  };\n\n  AbstractMatrix.pow = function pow(matrix, arg0) {\n    const newMatrix = new Matrix(matrix);\n    return newMatrix.pow(arg0);\n  };\n\n  AbstractMatrix.prototype.pow = function pow(value) {\n    if (typeof value === 'number') return this.powS(value);\n    return this.powM(value);\n  };\n\n  AbstractMatrix.prototype.powS = function powS(value) {\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), value));\n      }\n    }\n    return this;\n  };\n\n  AbstractMatrix.prototype.powM = function powM(matrix) {\n    matrix = Matrix.checkMatrix(matrix);\n    if (this.rows !== matrix.rows ||\n      this.columns !== matrix.columns) {\n      throw new RangeError('Matrices dimensions must be equal');\n    }\n    for (let i = 0; i < this.rows; i++) {\n      for (let j = 0; j < this.columns; j++) {\n        this.set(i, j, Math.pow(this.get(i, j), matrix.get(i, j)));\n      }\n    }\n    return this;\n  };\n}\n","import { getDiastereotopicAtomIDs } from '../diastereotopic/getDiastereotopicAtomIDs';\n\nimport { getHoseCodesFromDiastereotopicID } from './getHoseCodesFromDiastereotopicID';\n/**\n * Returns an array containing one entry per atom containing\n * diaID and hose code\n * @param {OCL.Molecule} molecule\n * @param {object} options\n */\n\nexport function getHoseCodesAndDiastereotopicIDs(molecule, options) {\n  const diaIDs = getDiastereotopicAtomIDs(molecule).map((oclID) => ({\n    oclID,\n  }));\n  // seems like a very slow approach\n  diaIDs.forEach(function(diaID) {\n    const hoses = getHoseCodesFromDiastereotopicID(diaID.oclID, options);\n    diaID.hoses = [];\n    let sphere = 0;\n    for (const hose of hoses) {\n      diaID.hoses.push({\n        sphere: sphere++,\n        oclID: hose,\n      });\n    }\n  });\n  return diaIDs;\n}\n","import { getOCL } from '../OCL';\n\n/**\n * Get the shortest path between each pair of atoms in the molecule\n * @param {OCL.Molecule} molecule\n * @param {object} [options={}]\n * @param {string} [opions.fromLabel='H']\n * @param {string} [opions.toLabel='H']\n * @param {string} [opions.minLenght=1]\n * @param {string} [opions.maxLength=4]\n * @returns {Array<Array>} A matrix containing on each cell (i,j) the shortest path from atom i to atom j\n */\nexport function getShortestPaths(molecule, options = {}) {\n  const OCL = getOCL();\n  const { fromLabel = '', toLabel = '', maxLength = 3 } = options;\n\n  let fromAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(fromLabel);\n  let toAtomicNumber = OCL.Molecule.getAtomicNoFromLabel(toLabel);\n\n  const nbAtoms = molecule.getAllAtoms();\n  let allShortestPaths = new Array(nbAtoms);\n  for (let i = 0; i < nbAtoms; i++) {\n    allShortestPaths[i] = new Array(nbAtoms);\n  }\n\n  for (let from = 0; from < nbAtoms; from++) {\n    allShortestPaths[from][from] = [from];\n    for (let to = from + 1; to < nbAtoms; to++) {\n      if (\n        (fromAtomicNumber === 0 ||\n          molecule.getAtomicNo(from) === fromAtomicNumber) &&\n        (toAtomicNumber === 0 || molecule.getAtomicNo(to) === toAtomicNumber)\n      ) {\n        let path = [];\n        molecule.getPath(path, from, to, maxLength);\n        if (path.length) {\n          allShortestPaths[from][to] = path.slice();\n          allShortestPaths[to][from] = path.reverse();\n        } else {\n          allShortestPaths[from][to] = null;\n          allShortestPaths[to][from] = null;\n        }\n      } else {\n        allShortestPaths[from][to] = null;\n        allShortestPaths[to][from] = null;\n      }\n    }\n  }\n\n  return allShortestPaths;\n}\n","import { getDiastereotopicAtomIDsAndH } from './getDiastereotopicAtomIDsAndH';\n\n/**\n * Returns a SVG\n * @param {*} molecule\n * @param {*} [options={}]\n */\nexport function toDiastereotopicSVG(molecule, options = {}) {\n  let {\n    width = 300,\n    height = 200,\n    prefix = 'ocl',\n    heavyAtomHydrogen = false,\n  } = options;\n  let svg = options.svg;\n  let diaIDs = [];\n\n  let hydrogenInfo = {};\n  getDiastereotopicAtomIDsAndH(molecule).forEach(function(line) {\n    hydrogenInfo[line.oclID] = line;\n  });\n\n  if (heavyAtomHydrogen) {\n    for (let i = 0; i < molecule.getAtoms(); i++) {\n      diaIDs.push([]);\n    }\n    let groupedDiaIDs = molecule.getGroupedDiastereotopicAtomIDs();\n    groupedDiaIDs.forEach(function(diaID) {\n      if (\n        hydrogenInfo[diaID.oclID] &&\n        hydrogenInfo[diaID.oclID].nbHydrogens > 0\n      ) {\n        diaID.atoms.forEach((atom) => {\n          hydrogenInfo[diaID.oclID].hydrogenOCLIDs.forEach((id) => {\n            if (!diaIDs[atom * 1].includes(id)) diaIDs[atom].push(id);\n          });\n        });\n      }\n    });\n  } else {\n    diaIDs = molecule.getDiastereotopicAtomIDs().map((a) => [a]);\n  }\n\n  if (!svg) svg = molecule.toSVG(width, height, prefix);\n\n  svg = svg.replace(/Atom:[0-9]+\"/g, function(value) {\n    let atom = value.replace(/[^0-9]/g, '');\n    return `${value} data-diaid=\"${diaIDs[atom].join(',')}\"`;\n  });\n\n  return svg;\n}\n"],"names":["OCL","getOCL","Error","xAtomicNumber","tagAtom","molecule","iAtom","customLabel","getAtomLabel","setAtomCustomLabel","getAtomicNo","setAtomicNo","Molecule","getAtomicNoFromLabel","getXAtomicNumber","setAtomMass","getAtomMass","addDiastereotopicMissingChirality","options","esrType","cESRTypeAnd","getAllAtoms","tempMolecule","getCompactCopy","ensureHelperArrays","cHelperBitsStereo","i","getAtoms","isAtomStereoCenter","getStereoBond","stereoBond","getAtomPreferredStereoBond","setBondType","cBondTypeUp","getBondAtom","connAtom","setBondAtom","setAtomESR","makeRacemic","cHelperCIP","getAtomParity","cAtomParityNone","getDiastereotopicAtomIDs","numberAtoms","ids","getCanonizedIDCode","CANONIZER_ENCODE_ATOM_CUSTOM_LABELS","getDiastereotopicAtomIDsAndH","originalMolecule","addImplicitHydrogens","cHelperNeighbours","diaIDs","newDiaIDs","length","newDiaID","oclID","hydrogenOCLIDs","nbHydrogens","j","getAllConnAtoms","atom","getConnAtom","indexOf","push","isCsp3","atomID","getAtomCharge","getImplicitHydrogens","getConnAtoms","FULL_HOSE_CODE","getHoseCodesForAtom","rootAtom","minSphereSize","maxSphereSize","kind","isTagged","tag","addMissingChirality","getAtomCustomLabel","fragment","results","min","max","atomMask","Array","atomList","sphere","newMax","copyMoleculeByAtoms","getHoseCodesFromDiastereotopicID","diastereotopicID","fromIDCode","atomCustomLabel","endsWith","getAtomsInfo","cHelperRings","result","extra","singleBonds","doubleBonds","tripleBonds","aromaticBonds","cnoHybridation","abnormalValence","getAtomAbnormalValence","charge","cipParity","getAtomCIPParity","color","getAtomColor","atomicNo","label","mass","radical","getAtomRadical","ringBondCount","getAtomRingBondCount","ringSize","getAtomRingSize","x","getAtomX","y","getAtomY","z","getAtomZ","allHydrogens","getAllHydrogens","connAtoms","allConnAtoms","implicitHydrogens","isAromatic","isAromaticAtom","isAllylic","isAllylicAtom","isStereoCenter","isRing","isRingAtom","isSmallRing","isSmallRingAtom","isStabilized","isStabilizedAtom","bond","getConnBond","bondOrder","getBondOrder","isAromaticBond","totalBonds","connectedAtom","hydrogenOnAtomicNo","labileHydrogen","toString","Object","prototype","object","call","input","isArray","TypeError","maxValue","minValue","rescale","output","arguments","undefined","currentMin","currentMax","RangeError","_options$min","autoMinMax","_options$max","factor","checkRowIndex","matrix","index","outer","rows","checkColumnIndex","columns","checkRowVector","vector","to1DArray","checkColumnVector","checkRowIndices","rowIndices","some","r","from","checkColumnIndices","columnIndices","c","checkRange","startRow","endRow","startColumn","endColumn","checkNumber","newArray","value","array","name","formatNumber","num","numStr","String","padEnd","precise","toPrecision","maxNumSize","exponential","toExponential","eIndex","e","substring","AbstractMatrix","newRows","newColumns","newData","newMatrix","Matrix","row","column","set","fill","random","Math","Number","isInteger","interval","round","this","zeros","data","l","matrix1","matrix2","checkMatrix","get","isMatrix","klass","apply","callback","to2DArray","copy","toJSON","isRowVector","isColumnVector","isVector","isSquare","isSymmetric","isEchelonForm","previousColumn","checked","isReducedEchelonForm","k","echelonForm","clone","h","iMax","swapRows","tmp","reducedEchelonForm","m","n","maxRow","p","pivot","repeat","setSubMatrix","neg","mulS","getRow","getRowVector","rowVector","setRow","row1","row2","temp","getColumn","getColumnVector","columnVector","setColumn","swapColumns","column1","column2","addRowVector","subRowVector","mulRowVector","divRowVector","addColumnVector","subColumnVector","mulColumnVector","divColumnVector","mulRow","mulColumn","v","maxIndex","idx","minIndex","maxRowIndex","minRow","minRowIndex","maxColumn","maxColumnIndex","minColumn","minColumnIndex","diag","norm","type","sqrt","cumulativeSum","sum","dot","vector2","vector1","mmul","other","Bcolj","Float64Array","s","strassen2x2","a11","b11","a12","b12","a21","b21","a22","b22","m1","m2","m3","m4","m5","c00","c01","c10","c11","strassen3x3","a00","a01","a02","a10","a20","b00","b01","b02","b10","b20","m6","m7","m8","m9","m12","m13","m14","m15","m16","m17","m18","c02","c12","c20","c21","c22","mmulStrassen","r1","c1","r2","c2","embed","mat","cols","resultat","console","warn","blockMult","a","b","halfRows","parseInt","halfCols","subMatrix","add","sub","scaleRows","isFinite","scaleColumns","flipRows","middle","ceil","first","last","flipColumns","kroneckerProduct","q","transpose","sortRows","compareFunction","compareNumbers","sort","sortColumns","subMatrixRow","indices","subMatrixColumn","selection","checkIndices","rowIndex","columnIndex","trace","by","sumByRow","sumByColumn","sumAll","product","productByRow","productByColumn","productAll","mean","size","variance","unbiased","sum1","sum2","varianceByRow","varianceByColumn","varianceAll","standardDeviation","center","centerByRow","centerByColumn","centerAll","scale","pow","getScaleByRow","scaleByRow","getScaleByColumn","scaleByColumn","divider","getScaleAll","scaleAll","Symbol","for","indent","indentData","constructor","maxI","maxJ","line","join","inspectData","rand","randomInt","randInt","diagonal","identity","eye","negate","tensorProduct","nRows","nColumns","arrayData","removeRow","splice","addRow","removeColumn","newRow","addColumn","getConnectivityMatrix","nbAtoms","map","pathLength","cRoundedMass","sdt","getConnBondOrder","adjMatrix","numVertices","distMatrix","val","POSITIVE_INFINITY","dist","floydWarshall","getHoseCodesForPath","to","maxLength","originalFrom","originalTo","torsion","originalAtoms","getPath","calculateTorsion","tag1","tag2","atoms","hoses","atomMap","addS","addM","subS","subM","subtract","subtractS","subtractM","mul","mulM","multiply","multiplyS","multiplyM","div","divS","divM","divide","divideS","divideM","mod","modS","modM","modulus","modulusS","modulusM","and","andS","andM","or","orS","orM","xor","xorS","xorM","leftShift","leftShiftS","leftShiftM","signPropagatingRightShift","signPropagatingRightShiftS","signPropagatingRightShiftM","rightShift","rightShiftS","rightShiftM","zeroFillRightShift","zeroFillRightShiftS","zeroFillRightShiftM","not","abs","acos","acosh","asin","asinh","atan","atanh","cbrt","clz32","cos","cosh","exp","expm1","floor","fround","log","log1p","log10","log2","sign","sin","sinh","tan","tanh","trunc","arg0","powS","powM","installMathOperations","forEach","diaID","hose","fromLabel","toLabel","minLength","fromAtomicNumber","toAtomicNumber","atomsInfo","pathLengthMatrix","paths","allShortestPaths","path","slice","reverse","newOCL","width","height","prefix","heavyAtomHydrogen","svg","hydrogenInfo","getGroupedDiastereotopicAtomIDs","id","includes","toSVG","replace"],"mappings":"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"}